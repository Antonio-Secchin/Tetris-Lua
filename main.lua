pieceStructures = {
    {
        {
            {' ', ' ', ' ', ' '},
            {'i', 'i', 'i', 'i'},
            {' ', ' ', ' ', ' '},
            {' ', ' ', ' ', ' '},
        },
        {
            {' ', 'i', ' ', ' '},
            {' ', 'i', ' ', ' '},
            {' ', 'i', ' ', ' '},
            {' ', 'i', ' ', ' '},
        },
    },
    {
        {
            {' ', ' ', ' ', ' '},
            {' ', 'o', 'o', ' '},
            {' ', 'o', 'o', ' '},
            {' ', ' ', ' ', ' '},
        },
    },
    {
        {
            {' ', ' ', ' ', ' '},
            {'j', 'j', 'j', ' '},
            {' ', ' ', 'j', ' '},
            {' ', ' ', ' ', ' '},
        },
        {
            {' ', 'j', ' ', ' '},
            {' ', 'j', ' ', ' '},
            {'j', 'j', ' ', ' '},
            {' ', ' ', ' ', ' '},
        },
        {
            {'j', ' ', ' ', ' '},
            {'j', 'j', 'j', ' '},
            {' ', ' ', ' ', ' '},
            {' ', ' ', ' ', ' '},
        },
        {
            {' ', 'j', 'j', ' '},
            {' ', 'j', ' ', ' '},
            {' ', 'j', ' ', ' '},
            {' ', ' ', ' ', ' '},
        },
    },
    {
        {
            {' ', ' ', ' ', ' '},
            {'l', 'l', 'l', ' '},
            {'l', ' ', ' ', ' '},
            {' ', ' ', ' ', ' '},
        },
        {
            {' ', 'l', ' ', ' '},
            {' ', 'l', ' ', ' '},
            {' ', 'l', 'l', ' '},
            {' ', ' ', ' ', ' '},
        },
        {
            {' ', ' ', 'l', ' '},
            {'l', 'l', 'l', ' '},
            {' ', ' ', ' ', ' '},
            {' ', ' ', ' ', ' '},
        },
        {
            {'l', 'l', ' ', ' '},
            {' ', 'l', ' ', ' '},
            {' ', 'l', ' ', ' '},
            {' ', ' ', ' ', ' '},
        },
    },
    {
        {
            {' ', ' ', ' ', ' '},
            {'t', 't', 't', ' '},
            {' ', 't', ' ', ' '},
            {' ', ' ', ' ', ' '},
        },
        {
            {' ', 't', ' ', ' '},
            {' ', 't', 't', ' '},
            {' ', 't', ' ', ' '},
            {' ', ' ', ' ', ' '},
        },
        {
            {' ', 't', ' ', ' '},
            {'t', 't', 't', ' '},
            {' ', ' ', ' ', ' '},
            {' ', ' ', ' ', ' '},
        },
        {
            {' ', 't', ' ', ' '},
            {'t', 't', ' ', ' '},
            {' ', 't', ' ', ' '},
            {' ', ' ', ' ', ' '},
        },
    },
    {
        {
            {' ', ' ', ' ', ' '},
            {' ', 's', 's', ' '},
            {'s', 's', ' ', ' '},
            {' ', ' ', ' ', ' '},
        },
        {
            {'s', ' ', ' ', ' '},
            {'s', 's', ' ', ' '},
            {' ', 's', ' ', ' '},
            {' ', ' ', ' ', ' '},
        },
    },
    {
        {
            {' ', ' ', ' ', ' '},
            {'z', 'z', ' ', ' '},
            {' ', 'z', 'z', ' '},
            {' ', ' ', ' ', ' '},
        },
        {
            {' ', 'z', ' ', ' '},
            {'z', 'z', ' ', ' '},
            {'z', ' ', ' ', ' '},
            {' ', ' ', ' ', ' '},
        },
    },
}

alfabeto = {
    A = {
        {" ", "j", "j", "j", " "},
        {"j", " ", " ", " ", "j"},
        {"j", "j", "j", "j", "j"},
        {"j", " ", " ", " ", "j"},
        {"j", " ", " ", " ", "j"}
    },
    B = {
        {"j", "j", "j", " ", " "},
        {"j", " ", " ", "j", " "},
        {"j", "j", "j", " ", " "},
        {"j", " ", " ", "j", " "},
        {"j", "j", "j", " ", " "}
    },
    C = {
        {" ", "j", "j", "j", " "},
        {"j", " ", " ", " ", " "},
        {"j", " ", " ", " ", " "},
        {"j", " ", " ", " ", " "},
        {" ", "j", "j", "j", " "}
    },
    D = {
        {"j", "j", "j", " ", " "},
        {"j", " ", " ", "j", " "},
        {"j", " ", " ", "j", " "},
        {"j", " ", " ", "j", " "},
        {"j", "j", "j", " ", " "}
    },
    E = {
        {"j", "j", "j", "j", " "},
        {"j", " ", " ", " ", " "},
        {"j", "j", "j", " ", " "},
        {"j", " ", " ", " ", " "},
        {"j", "j", "j", "j", " "}
    },
    F = {
        {"j", "j", "j", "j", " "},
        {"j", " ", " ", " ", " "},
        {"j", "j", "j", " ", " "},
        {"j", " ", " ", " ", " "},
        {"j", " ", " ", " ", " "}
    },
    G = {
        {" ", "j", "j", "j", " "},
        {"j", " ", " ", " ", " "},
        {"j", " ", "j", "j", " "},
        {"j", " ", " ", "j", " "},
        {" ", "j", "j", "j", " "}
    },
    H = {
        {"j", " ", " ", " ", "j"},
        {"j", " ", " ", " ", "j"},
        {"j", "j", "j", "j", "j"},
        {"j", " ", " ", " ", "j"},
        {"j", " ", " ", " ", "j"}
    },
    I = {
        {"j", "j", "j", "j", "j"},
        {" ", " ", "j", " ", " "},
        {" ", " ", "j", " ", " "},
        {" ", " ", "j", " ", " "},
        {"j", "j", "j", "j", "j"}
    },
    J = {
        {" ", " ", "j", "j", "j"},
        {" ", " ", " ", " ", "j"},
        {" ", " ", " ", " ", "j"},
        {"j", " ", " ", " ", "j"},
        {" ", "j", "j", "j", " "}
    },
    K = {
        {"j", " ", " ", "j", " "},
        {"j", " ", "j", " ", " "},
        {"j", "j", " ", " ", " "},
        {"j", " ", "j", " ", " "},
        {"j", " ", " ", "j", " "}
    },
    L = {
        {"j", " ", " ", " ", " "},
        {"j", " ", " ", " ", " "},
        {"j", " ", " ", " ", " "},
        {"j", " ", " ", " ", " "},
        {"j", "j", "j", "j", " "}
    },
    M = {
        {"j", " ", " ", " ", "j"},
        {"j", "j", " ", "j", "j"},
        {"j", " ", "j", " ", "j"},
        {"j", " ", " ", " ", "j"},
        {"j", " ", " ", " ", "j"}
    },
    N = {
        {"j", " ", " ", " ", "j"},
        {"j", "j", " ", " ", "j"},
        {"j", " ", "j", " ", "j"},
        {"j", " ", " ", "j", "j"},
        {"j", " ", " ", " ", "j"}
    },
    O = {
        {" ", "j", "j", "j", " "},
        {"j", " ", " ", " ", "j"},
        {"j", " ", " ", " ", "j"},
        {"j", " ", " ", " ", "j"},
        {" ", "j", "j", "j", " "}
    },
    P = {
        {"j", "j", "j", " ", " "},
        {"j", " ", " ", "j", " "},
        {"j", "j", "j", " ", " "},
        {"j", " ", " ", " ", " "},
        {"j", " ", " ", " ", " "}
    },
    Q = {
        {" ", "j", "j", " ", " "},
        {"j", " ", " ", "j", " "},
        {"j", " ", " ", "j", " "},
        {"j", " ", "j", " ", " "},
        {" ", "j", "j", "j", "j"}
    },
    R = {
        {"j", "j", "j", " ", " "},
        {"j", " ", " ", "j", " "},
        {"j", "j", "j", " ", " "},
        {"j", " ", "j", " ", " "},
        {"j", " ", " ", "j", " "}
    },
    S = {
        {" ", "j", "j", "j", " "},
        {"j", " ", " ", " ", " "},
        {" ", "j", "j", " ", " "},
        {" ", " ", " ", "j", " "},
        {"j", "j", "j", " ", " "}
    },
    T = {
        {"j", "j", "j", "j", "j"},
        {" ", " ", "j", " ", " "},
        {" ", " ", "j", " ", " "},
        {" ", " ", "j", " ", " "},
        {" ", " ", "j", " ", " "}
    },
    U = {
        {"j", " ", " ", " ", "j"},
        {"j", " ", " ", " ", "j"},
        {"j", " ", " ", " ", "j"},
        {"j", " ", " ", " ", "j"},
        {" ", "j", "j", "j", " "}
    },
    V = {
        {"j", " ", " ", " ", "j"},
        {"j", " ", " ", " ", "j"},
        {"j", " ", " ", " ", "j"},
        {" ", "j", " ", "j", " "},
        {" ", " ", "j", " ", " "}
    },
    W = {
        {"j", " ", " ", " ", "j"},
        {"j", " ", " ", " ", "j"},
        {"j", " ", "j", " ", "j"},
        {"j", "j", " ", "j", "j"},
        {"j", " ", " ", " ", "j"}
    },
    X = {
        {"j", " ", " ", " ", "j"},
        {" ", "j", " ", "j", " "},
        {" ", " ", "j", " ", " "},
        {" ", "j", " ", "j", " "},
        {"j", " ", " ", " ", "j"}
    },
    Y = {
        {"j", " ", " ", " ", "j"},
        {" ", "j", " ", "j", " "},
        {" ", " ", "j", " ", " "},
        {" ", " ", "j", " ", " "},
        {" ", " ", "j", " ", " "}
    },
    Z = {
        {"j", "j", "j", "j", "j"},
        {" ", " ", " ", "j", " "},
        {" ", " ", "j", " ", " "},
        {" ", "j", " ", " ", " "},
        {"j", "j", "j", "j", "j"}
    },    
}

function newSequence()
    sequence = {}
    for pieceTypeIndex = 1, #pieceStructures do
        local position = love.math.random(#sequence + 1)
        table.insert(
            sequence,
            position,
            pieceTypeIndex
        )
    end
end

function love.load()
    love.graphics.setBackgroundColor(1, 1, 1)

    font = love.graphics.newFont("Brick Tetris.ttf", 43)
    love.graphics.setFont(font)

    creditos = false
    resetar = false

    -- Tamanho do grid
    gridXCount = 10
    gridYCount = 18

    blockSize = 20

    -- Tamanho das matrizes de peça
    pieceXCount = 4
    pieceYCount = 4

    -- Tamanho das matrizes de letra
    letterYCount = 5
    letterXCount = 5

    score = 0
    dy = 0

    inert = {}
    for y = 1, gridYCount do
        inert[y] = {}
        for x = 1, gridXCount do
            inert[y][x] = ' '
        end
    end
    pieceType = 1
    pieceRotation = 1

    pieceX = 3
    pieceY = 0

    timer = 0
    timerLimit = 0.5

    newSequence()

    function newPiece()
        pieceX = 3
        pieceY = 0
        pieceRotation = 1
        pieceType = table.remove(sequence)
    
        if #sequence == 0 then
            newSequence()
        end
    end

    function reset()
        inert = {}
        for y = 1, gridYCount do
            inert[y] = {}
            for x = 1, gridXCount do
                inert[y][x] = ' '
            end
        end

        newSequence()
        newPiece()

        score = 0
        timer = 0
    end

    reset()
    
end

function canPieceMove(testX, testY, testRotation)
    for y = 1, pieceYCount do
        for x = 1, pieceXCount do
            local testBlockX = testX + x
            local testBlockY = testY + y

            if pieceStructures[pieceType][testRotation][y][x] ~= ' ' and (testBlockX < 1 or testBlockX > gridXCount or testBlockY > gridYCount or inert[testBlockY][testBlockX] ~= ' ')
            then
                return false
            end
        end
    end

    return true
end

function love.draw()
    -- Desenha blocos no grid (incluindo os cinzas, que é ele mesmo)
    local function drawBlock(block, x, y)
        local colors = {
            [' '] = {.87, .87, .87},
            i = {.47, .76, .94},
            j = {.93, .91, .42},
            l = {.49, .85, .76},
            o = {.92, .69, .47},
            s = {.83, .54, .93},
            t = {.97, .58, .77},
            z = {.66, .83, .46},
            preview = {.75, .75, .75},
        }
        local color = colors[block]
        love.graphics.setColor(color)

        local blockDrawSize = blockSize - 1
        love.graphics.rectangle(
            'fill',
            (x - 1) * blockSize,
            (y - 1) * blockSize,
            blockDrawSize,
            blockDrawSize
        )
    end

    -- Usados para "centralizar" o grid
    local gridOffsetX = 2
    local gridOffsetY = 5
    
    local function drawGrid(extraX, extraY) 
        -- Se a variável for nil, coloca 0 nela.
        extraX = extraX or 0
        extraY = extraY or 0

        for y = 1, gridYCount + extraY do
            for x = 1, gridXCount + extraX do
                drawBlock(inert[y][x], x + gridOffsetX, y + gridOffsetY)
            end
        end
    end

    local function drawLetter(letter, letterOffsetX, letterOffsetY)
        -- Se a variável for nil, coloca 0 nela.
        letterOffsetX = letterOffsetX or 0
        letterOffsetY = letterOffsetY or 0

        -- Imprime a letra (letterYCount e letterXCount falam o tamanho da matriz-letra)
        for y = 1, letterYCount do
            -- Para não imprimir fora das bordas
            if (dy - (y + letterOffsetY) >= 0) and (gridYCount + (y + letterOffsetY) - dy > 0) then
                for x = 1, letterXCount do
                    
                    local block = letter[y][x]

                    if block ~= ' ' then
                        local offsetX = gridOffsetX + letterOffsetX
                        local offsetY = gridOffsetY + letterOffsetY

                        --[[
                        --  gridYCount porque queremos que ele comece na parte de baixo do grid.
                        --  + y porque imprimimos letras usando várias linhas. Então elas não podem estar em uma só.
                        --  - dy é o que move a letra para cima constantemente.
                        --]]
                        drawBlock(block, x + offsetX, gridYCount + y - dy + offsetY)
                    end

                end
            end
        end

    end

    -- Para podermos desenhar peças em qualquer lugar da tela. É um pouco de modularização.
    local function drawPiece (piece, offsetX, offsetY, cor)
        -- Se a variável for nil, coloca 0 nela.
        offsetX = offsetX or 0
        offsetY = offsetY or 0

        -- O usuário inseriu uma cor, mas nossas cores são acessadas via string.
        if cor and type(cor) ~= 'string' then
            return false
        end

        for y = 1, pieceYCount do
            for x = 1, pieceXCount do
                local block = piece[y][x]
                if block ~= ' ' then
                    -- Se preview for nil/false, retorna block.
                    drawBlock(cor or block, x + offsetX, y + offsetY)
                end
            end
        end
    end

    function drawScore(extraX, extraY)
        -- Se a variável for nil, coloca 0 nela.
        extraX = extraX or 0
        extraY = extraY or 0

        -- Preferi sem scoreOffsetY
        local scoreOffsetX = gridXCount+1

        love.graphics.print(score, (gridOffsetX + scoreOffsetX + extraX) * blockSize, (gridOffsetY + extraY) * blockSize)
    end

    if not creditos then
        drawGrid()
        drawScore()
        
        -- Desenha o bloco
        local piece = pieceStructures[pieceType][pieceRotation]
        drawPiece(piece, pieceX + gridOffsetX, pieceY + gridOffsetY)
        
        -- Desenha a preview do próximo bloco 
        piece = pieceStructures[sequence[#sequence]][1]
        drawPiece(piece, gridOffsetX + 3, gridOffsetY - 4, 'preview')

    else
        -- Adiciona 10 colunas (X + 10)
        drawGrid(10)
        drawScore(10)
        
        local letters ={alfabeto.G,
                        alfabeto.A,
                        alfabeto.M,
                        alfabeto.E}

        for i = 1, #letters do
            drawLetter(letters[i], (i-1)*5)
        end

        letters = { alfabeto.O,
                    alfabeto.V,
                    alfabeto.E,
                    alfabeto.R}

        for i = 1, #letters do
            drawLetter(letters[i], (i-1)*5, 6)
        end

        if dy >= gridYCount + 11 then
            resetar = true;
        end

    end
end

function love.keypressed(key)
    if key == 'x' then
        local testRotation = pieceRotation + 1
        if testRotation > #pieceStructures[pieceType] then
            testRotation = 1
        end

        if canPieceMove(pieceX, pieceY, testRotation) then
            pieceRotation = testRotation
        end

    elseif key == 'z' then
        local testRotation = pieceRotation - 1
        if testRotation < 1 then
            testRotation = #pieceStructures[pieceType]
        end

        if canPieceMove(pieceX, pieceY, testRotation) then
            pieceRotation = testRotation
        end

    elseif key == 'left' then
        local testX = pieceX - 1

        if canPieceMove(testX, pieceY, pieceRotation) then
            pieceX = testX
        end

    elseif key == 'right' then
        local testX = pieceX + 1

        if canPieceMove(testX, pieceY, pieceRotation) then
            pieceX = testX
        end

    elseif key == 'c' then
        while canPieceMove(pieceX, pieceY + 1, pieceRotation) do
            pieceY = pieceY + 1
            timer = timerLimit
        end
    elseif key == 'down' then
        timerLimit = 0.1
    end
end

function love.keyreleased(key)
    if key == 'down' then
        timerLimit = 0.5
    end
end

function love.update(dt)
    if creditos then
        timer = timer + dt
        -- 0.11 pareceu uma boa velocidade. Melhor que timerLimit para isso, na minha opinião.
        if timer >= 0.11 then
            dy = dy + 1
            timer = 0
        end
    end
    if resetar then
        creditos = false
        resetar = false
        score = 0
        dy = 0
        reset()
    end
    if not creditos then
        timer = timer + dt
        if timer >= timerLimit then
            timer = 0
            local testY = pieceY + 1
            if canPieceMove(pieceX, testY, pieceRotation) then
                pieceY = testY
            else
                -- Coloca a peça atual como inerte
                for y = 1, pieceYCount do
                    for x = 1, pieceXCount do
                        local block =
                            pieceStructures[pieceType][pieceRotation][y][x]
                        if block ~= ' ' then
                            inert[pieceY + y][pieceX + x] = block
                        end
                    end
                end

                -- Checa se alguma linha foi completamente preenchida
                for y = 1, gridYCount do
                    local complete = true
                    for x = 1, gridXCount do
                        if inert[y][x] == ' ' then
                            complete = false
                            break
                        end
                    end
                    
                    if complete then

                        -- Retira a linha preenchida (e move o resto para baixo)
                        for removeY = y, 2, -1 do
                            for removeX = 1, gridXCount do
                                inert[removeY][removeX] =
                                inert[removeY - 1][removeX]
                            end
                        end

                        for removeX = 1, gridXCount do
                            inert[1][removeX] = ' '
                        end

                        score = score + 100
                        
                        drawScore()
                    end

                end

                newPiece()
            end

            if not canPieceMove(pieceX, pieceY, pieceRotation) then
                inert = {}
                for y = 1, gridYCount do
                    inert[y] = {}
                    for x = 1, (gridXCount + 10) do
                        inert[y][x] = ' '
                    end
                end
                timer = 0
                creditos = true
            end
        end
    end
end